var documenterSearchIndex = {"docs":
[{"location":"interface/#Interfaces","page":"Interface","title":"Interfaces","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"All binary searching trees are subtypes of AbstractBinTree{T}. ","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"AbstractBinTree{T}","category":"page"},{"location":"interface/#SearchingTrees.SearchingTreeCore.AbstractBinTree","page":"Interface","title":"SearchingTrees.SearchingTreeCore.AbstractBinTree","text":"abstract type AbstractBinTree{T} <: AbstractNode{T}\n\nAbstractBinTree is an abstract type for binary trees. It is a subtype of AbstractTrees.AbstractNode{T}.\n\ninterface\n\nSuch methods should be implemented for AbstractBinTree{T}:\n\nleft(t::AbstractBinTree): return the left child of t. The default implementation is t.left.\nright(t::AbstractBinTree): return the right child of t. The default implementation is t.right.\nparent(t::AbstractBinTree): return the parent of t. This should be implemented if you want to use the default iterate method. The default implementation is t.parent.\nnodevalue(t::AbstractBinTree{T}): return the value of t of type T.\n\n\n\n\n\n","category":"type"},{"location":"red_black_tree/#Red-Black-Tree","page":"Red-Black Tree","title":"Red Black Tree","text":"","category":"section"},{"location":"red_black_tree/#Introduction","page":"Red-Black Tree","title":"Introduction","text":"","category":"section"},{"location":"red_black_tree/","page":"Red-Black Tree","title":"Red-Black Tree","text":"Red Black Tree is a self-balancing binary search tree.  It is a binary search tree with one extra bit of information per node: the color, which is either red or black.  By constraining the node colors on any simple path from the root to a leaf, red-black tree ensures that no such path is more than twice as long as any other, so that the tree is approximately balanced. A red-black tree is a binary search tree that satisfies the following red-black properties:","category":"page"},{"location":"red_black_tree/","page":"Red-Black Tree","title":"Red-Black Tree","text":"Every node is either red or black.\nThe root is black.\nA red node cannot have a red child.\nEvery path from the root to a leaf contains the same number of black nodes.","category":"page"},{"location":"red_black_tree/#API","page":"Red-Black Tree","title":"API","text":"","category":"section"},{"location":"red_black_tree/","page":"Red-Black Tree","title":"Red-Black Tree","text":"RBTreeMap{K, V}\nBase.get(d::RBTreeMap{K, V}, key::K, default) where {K, V}\nBase.getindex(d::RBTreeMap{K, V}, key::K) where {K, V}\nBase.setindex!(d::RBTreeMap{K, V}, value::V, key::K) where{K, V}\nBase.delete!(d::RBTreeMap{K, V}, key::K) where {K, V}\nBase.iterate(d::RBTreeMap{K, V}) where {K, V}\nBase.empty(d::RBTreeMap{K, V}) where {K, V}\nBase.empty!(d::RBTreeMap{K, V}) where {K, V}","category":"page"},{"location":"red_black_tree/#SearchingTrees.RBTrees.RBTreeMap","page":"Red-Black Tree","title":"SearchingTrees.RBTrees.RBTreeMap","text":"RBTreeMap{K, V}\n\nA red-black tree map with key type K and value type V.\n\nFields\n\nroot::Union{RBTreeMapNode{K, V}, Nil}: the root node of the tree, might either be a RBTreeMapNode or nil when the tree is empty.\n\nConstructors\n\nRBTreeMap{K, V}(): create an empty tree map\n\nAn RBTreeMap is a subtype of AbstractDict{K, V} and it is an ordered map based on red-black tree data structure. It implements the following interfaces:\n\nBase.get(d::RBTreeMap{K, V}, key::K, default) where{K, V}: \nBase.getindex(d::RBTreeMap{K, V}, key::K) where{K, V}\nBase.setindex!(d::RBTreeMap{K, V}, value::V, key::K) where{K, V}\nBase.delete!(d::RBTreeMap{K, V}, key::K) where{K, V}\nBase.iterate(d::RBTreeMap{K, V}) where{K, V}\nBase.empty(d::RBTreeMap{K, V}) where{K, V}: return an empty RBTreeMap with the same key and value types as d\nBase.empty!(d::RBTreeMap{K, V}) where{K, V}: empty d in place\nBase.isempty(d::RBTreeMap{K, V}) where{K, V}: return true if d is empty\n\n\n\n\n\n","category":"type"},{"location":"red_black_tree/#Base.get-Union{Tuple{V}, Tuple{K}, Tuple{RBTreeMap{K, V}, K, Any}} where {K, V}","page":"Red-Black Tree","title":"Base.get","text":"Base.get(d::RBTreeMap{K, V}, key::K, default)\n\nGet the value of key in d, return default if key is not in d\n\n\n\n\n\n","category":"method"},{"location":"red_black_tree/#Base.getindex-Union{Tuple{V}, Tuple{K}, Tuple{RBTreeMap{K, V}, K}} where {K, V}","page":"Red-Black Tree","title":"Base.getindex","text":"Base.getindex(d::RBTreeMap{K, V}, key::K)\n\nGet the value of key in d, throw KeyError if key is not in d. Called by d[key].\n\n\n\n\n\n","category":"method"},{"location":"red_black_tree/#Base.setindex!-Union{Tuple{V}, Tuple{K}, Tuple{RBTreeMap{K, V}, V, K}} where {K, V}","page":"Red-Black Tree","title":"Base.setindex!","text":"Base.setindex!(d::RBTreeMap{K, V}, value::V, key::K)\n\nSet the value of key in d to value. Called by d[key] = value.\n\n\n\n\n\n","category":"method"},{"location":"red_black_tree/#Base.delete!-Union{Tuple{V}, Tuple{K}, Tuple{RBTreeMap{K, V}, K}} where {K, V}","page":"Red-Black Tree","title":"Base.delete!","text":"Base.delete!(d::RBTreeMap{K, V}, key::K)\n\nDelete key in d. Called by delete!(d, key).\n\n\n\n\n\n","category":"method"},{"location":"red_black_tree/#Base.iterate-Union{Tuple{RBTreeMap{K, V}}, Tuple{V}, Tuple{K}} where {K, V}","page":"Red-Black Tree","title":"Base.iterate","text":"Base.iterate(d::RBTreeMap{K, V})\n\nIterate through d in ascending order of keys.\n\n\n\n\n\n","category":"method"},{"location":"red_black_tree/#Base.empty-Union{Tuple{RBTreeMap{K, V}}, Tuple{V}, Tuple{K}} where {K, V}","page":"Red-Black Tree","title":"Base.empty","text":"Base.empty(d::RBTreeMap{K, V})\n\nReturn an empty RBTreeMap with the same key and value types as d.\n\n\n\n\n\n","category":"method"},{"location":"red_black_tree/#Base.empty!-Union{Tuple{RBTreeMap{K, V}}, Tuple{V}, Tuple{K}} where {K, V}","page":"Red-Black Tree","title":"Base.empty!","text":"Base.empty!(d::RBTreeMap{K, V})\n\nEmpty d in place.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SearchingTrees","category":"page"},{"location":"#SearchingTrees.jl","page":"Home","title":"SearchingTrees.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SearchingTrees.jl, searching tree container for Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package provides several searching tree containers and corresponding Map containers, including:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Binary Search Tree\nRed-Black Tree","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"index.md\", \n    \"interface.md\", \n    \"red_black_tree.md\",\n]","category":"page"}]
}
